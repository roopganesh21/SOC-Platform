const {
  generateAuthTimestamp,
  generateSequentialTimestamps,
  generateRandomTimestamp,
} = require('./timestampGenerator');

const { ATTACKER_IPS, USERNAMES } = require('../../config/attackPatterns');

function randInt(min, max) {
  const lo = Math.ceil(min);
  const hi = Math.floor(max);
  return Math.floor(Math.random() * (hi - lo + 1)) + lo;
}

function pick(arr, fallback = null) {
  if (!arr || arr.length === 0) return fallback;
  return arr[randInt(0, arr.length - 1)];
}

function randomPid() {
  return randInt(1000, 9999);
}

function randomPort() {
  return randInt(1024, 65535);
}

function randomTty() {
  return `pts/${randInt(0, 3)}`;
}

function randomPwd() {
  return pick(['/home', '/var', '/etc', '/tmp', '/opt', '/srv'], '/home') +
    '/' +
    pick(USERNAMES.valid, 'user');
}

function ensureAuthTimestamp(timestamp) {
  if (!timestamp) return generateAuthTimestamp();
  if (timestamp instanceof Date) return generateAuthTimestamp(timestamp);
  // If caller passed a preformatted string, keep it.
  if (typeof timestamp === 'string') return timestamp;
  return generateAuthTimestamp(new Date(timestamp));
}

function ensureIp(ip) {
  return ip || pick(ATTACKER_IPS, '45.142.212.61');
}

/**
 * Generate a failed SSH attempt for an invalid user.
 *
 * @param {string} ip
 * @param {string} username
 * @param {Date|string} [timestamp]
 * @returns {string}
 */
function generateFailedSSH(ip, username, timestamp) {
  const ts = ensureAuthTimestamp(timestamp);
  const attackerIp = ensureIp(ip);
  const user = username || pick(USERNAMES.invalid, 'admin');
  const pid = randomPid();
  const port = randomPort();

  return `${ts} server sshd[${pid}]: Failed password for invalid user ${user} from ${attackerIp} port ${port} ssh2`;
}

/**
 * Generate a successful SSH login.
 *
 * @param {string} ip
 * @param {string} username
 * @param {Date|string} [timestamp]
 * @returns {string}
 */
function generateSuccessfulSSH(ip, username, timestamp) {
  const ts = ensureAuthTimestamp(timestamp);
  const sourceIp = ip || '10.0.0.50';
  const user = username || pick(USERNAMES.valid, 'john');
  const pid = randomPid();
  const port = randomPort();

  return `${ts} server sshd[${pid}]: Accepted password for ${user} from ${sourceIp} port ${port} ssh2`;
}

/**
 * Generate a sudo violation line.
 *
 * @param {string} username
 * @param {Date|string} [timestamp]
 * @returns {string}
 */
function generateSudoViolation(username, timestamp) {
  const ts = ensureAuthTimestamp(timestamp);
  const user = username || pick(USERNAMES.valid, 'alice');
  const tty = randomTty();
  const pwd = randomPwd();
  const cmd = pick(['/bin/bash', '/bin/sh', '/usr/bin/su', '/bin/cat /etc/shadow'], '/bin/bash');

  return `${ts} server sudo: ${user} : user NOT in sudoers ; TTY=${tty} ; PWD=${pwd} ; USER=root ; COMMAND=${cmd}`;
}

/**
 * Generate an invalid user attempt (alias of generateFailedSSH).
 *
 * @param {string} ip
 * @param {string} username
 * @param {Date|string} [timestamp]
 * @returns {string}
 */
function generateInvalidUser(ip, username, timestamp) {
  return generateFailedSSH(ip, username, timestamp);
}

/**
 * Generate a disconnect / reset message for SSH.
 *
 * @param {string} ip
 * @param {Date|string} [timestamp]
 * @returns {string}
 */
function generateAuthDisconnect(ip, timestamp) {
  const ts = ensureAuthTimestamp(timestamp);
  const sourceIp = ensureIp(ip);
  const pid = randomPid();
  const port = randomPort();

  const variants = [
    `Received disconnect from ${sourceIp} port ${port}:11: Bye Bye [preauth]`,
    `Connection reset by ${sourceIp} port ${port} [preauth]`,
    `Disconnected from invalid user ${pick(USERNAMES.invalid, 'admin')} ${sourceIp} port ${port} [preauth]`,
  ];

  return `${ts} server sshd[${pid}]: ${pick(variants)}`;
}

/**
 * Generate a brute force sequence of failed attempts.
 *
 * @param {string} attackerIP
 * @param {string} targetUser
 * @param {number} count
 * @param {Date} [startTime]
 * @returns {string[]}
 */
function generateBruteForceSequence(attackerIP, targetUser, count, startTime = new Date()) {
  const n = Math.max(0, Number(count || 0));
  const base = startTime instanceof Date ? startTime : new Date(startTime);

  const lines = [];
  let cursor = new Date(base);

  for (let i = 0; i < n; i += 1) {
    const interval = randInt(2, 5);
    cursor = new Date(cursor.getTime() + interval * 1000);

    // Keep this sequence strictly parseable by the current auth.log parser
    // (disconnect/reset lines are generated by generateAuthDisconnect, but are
    // not part of the brute force sequence by default).
    lines.push(generateFailedSSH(attackerIP, targetUser || pick(USERNAMES.invalid, 'admin'), cursor));
  }

  return lines;
}

function randomPrivateIp() {
  const ranges = [
    () => `10.${randInt(0, 255)}.${randInt(0, 255)}.${randInt(1, 254)}`,
    () => `192.168.${randInt(0, 255)}.${randInt(1, 254)}`,
    () => `172.${randInt(16, 31)}.${randInt(0, 255)}.${randInt(1, 254)}`,
  ];
  return pick(ranges)();
}

/**
 * Generate a mix of "normal" auth activity.
 *
 * @param {number} count
 * @returns {string[]}
 */
function generateNormalAuthActivity(count) {
  const n = Math.max(0, Number(count || 0));
  const now = new Date();
  const start = new Date(now.getTime() - 24 * 60 * 60 * 1000);

  const lines = [];

  for (let i = 0; i < n; i += 1) {
    const t = generateRandomTimestamp({ start, end: now });

    const roll = Math.random();
    if (roll < 0.65) {
      lines.push(generateSuccessfulSSH(randomPrivateIp(), pick(USERNAMES.valid), t));
    } else if (roll < 0.9) {
      // Occasional invalid user noise
      lines.push(generateInvalidUser(pick(ATTACKER_IPS), pick(USERNAMES.invalid), t));
    } else {
      // Rare sudo issue
      lines.push(generateSudoViolation(pick(USERNAMES.valid), t));
    }
  }

  // Sort by timestamp (lexicographic works for this fixed-width auth timestamp format only
  // if month/day differ; to be safe, just leave as generated. For the parser/demos, order isn't required.)
  return lines;
}

module.exports = {
  generateFailedSSH,
  generateSuccessfulSSH,
  generateSudoViolation,
  generateInvalidUser,
  generateAuthDisconnect,
  generateBruteForceSequence,
  generateNormalAuthActivity,
  // export timestamp helpers used by generators (optional)
  generateAuthTimestamp,
  generateSequentialTimestamps,
};
